/**
 * @module visualizations/imageGenerator
 * @description Creates static images of fractal data using the Canvas API.
 * Integrates with the fractal generation process to provide visual representations of generated fractals.
 * This module is responsible for:
 * - Converting fractal data points into visual representations
 * - Customizing image properties such as size, colors, and point sizes
 * - Scaling fractal data to fit within the image dimensions
 * - Saving the generated image to the file system with metadata
 * - Handling file naming conflicts
 * 
 * This module relates to other parts of the application as follows:
 * 
 * - @index.js: The main entry point may use this module to generate images after fractal data is computed.
 * - @index.html: While not directly related, the generated images could be displayed in the HTML interface.
 * - @script.js: The client-side script could request image generation via API calls, which would then use this module.
 * - @edge.js: Optimizes image generation for edge runtime environments.
 * - @server.js: Handles HTTP requests for fractal image generation.
 * - @outputHandler.js: Utilizes this module to generate visual outputs of fractal data.
 * - @modelSelector.js: The fractal data generated by models in modelSelector.js can be visualized using this module.
 * - @inputHandler.js: User inputs processed by inputHandler.js may include parameters for image generation, which would be passed to this module.
 * - @fractalService.js: This service could use imageGenerator.js to create visual representations of the fractals it generates.
 * - @fractionalSolver.js: The numerical solutions produced by fractionalSolver.js can be visualized using this module.
 * 
 * @example
 * import { createFractalImage } from './imageGenerator.js';
 * import { generateFractalData } from '../fractals/generator.js';
 * 
 * const fractalData = await generateFractalData(params);
 * const imageOptions = {
 *   width: 1024,
 *   height: 768,
 *   backgroundColor: '#1a1a1a',
 *   pointColor: '#00ff00',
 *   pointSize: 1,
 *   metadata: {
 *     fractalType: 'Mandelbrot',
 *     iterations: 1000,
 *     zoom: 2.5
 *   }
 * };
 * 
 * try {
 *   const imagePath = await createFractalImage(fractalData, imageOptions);
 *   console.log('Fractal image created successfully at:', imagePath);
 * } catch (error) {
 *   console.error('Error creating fractal image:', error);
 * }
 * 
 * @since 1.1.2
 */

import { createCanvas } from 'canvas';
import fs from 'fs/promises';
import path from 'path';
import { validateArray, validateObject, validateNumber, validateString } from '../utils/validators.js';
import logger from '../utils/logger.js';
import { generateFractalData } from '../models/modelSelector.js';
import { processInputs } from '../utils/inputHandler.js';
import { processFractalRequest } from '../fractalService.js';
import { ParallelComputation } from '../utils/parallelComputation.js';

/**
 * Creates a static image of fractal data with metadata.
 * @async
 * @function
 * @param {Array<{x: number, y: number}>} data - The fractal data points to visualize.
 * @param {Object} [options] - Optional parameters for image generation.
 * @param {number} [options.width=800] - The width of the image in pixels.
 * @param {number} [options.height=600] - The height of the image in pixels.
 * @param {string} [options.backgroundColor='#000000'] - The background color of the image.
 * @param {string} [options.pointColor='#FFFFFF'] - The color of the fractal data points.
 * @param {number} [options.pointSize=1] - The size of each data point in pixels.
 * @param {string} [options.outputPath='visualizations/fractalImage.png'] - The base output path for the generated image.
 * @param {Object} [options.metadata={}] - Metadata to be added to the image file.
 * @throws {Error} If there's an issue creating or saving the image.
 * @returns {Promise<string>} The path of the saved image file.
 */
export async function createFractalImage(data, options = {}) {
  try {
    validateArray(data, 'Fractal data');
    validateObject(options, 'Image options');

    const {
      width = 800,
      height = 600,
      backgroundColor = '#000000',
      pointColor = '#FFFFFF',
      pointSize = 1,
      outputPath = path.join('visualizations', 'fractalImage.png'),
      metadata = {}
    } = options;

    validateNumber(width, 'Width', 1, 10000);
    validateNumber(height, 'Height', 1, 10000);
    validateString(backgroundColor, 'Background color');
    validateString(pointColor, 'Point color');
    validateNumber(pointSize, 'Point size', 1, 10);
    validateString(outputPath, 'Output path');
    validateObject(metadata, 'Metadata');

    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // Draw background
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);

    // Scale data
    const [minX, maxX] = findMinMax(data, 'x');
    const [minY, maxY] = findMinMax(data, 'y');

    // Draw fractal data points
    ctx.fillStyle = pointColor;
    data.forEach(point => {
      const x = scaleValue(point.x, minX, maxX, 0, width);
      const y = height - scaleValue(point.y, minY, maxY, 0, height); // Invert Y-axis
      ctx.fillRect(x, y, pointSize, pointSize);
    });

    // Generate unique filename
    const { dir, name, ext } = path.parse(outputPath);
    let finalPath = outputPath;
    let counter = 1;
    while (await fileExists(finalPath)) {
      finalPath = path.join(dir, `${name}_${counter}${ext}`);
      counter++;
    }

    // Save image with metadata
    const buffer = canvas.toBuffer('image/png');
    await fs.writeFile(finalPath, buffer);
    await addMetadata(finalPath, metadata);

    logger.info(`Fractal image saved to ${finalPath}`);
    return finalPath;
  } catch (error) {
    logger.error('Error creating or saving the fractal image:', error);
    throw new Error('Failed to create or save the fractal image');
  }
}

/**
 * Checks if a file exists.
 * @async
 * @function
 * @param {string} filePath - The path to check.
 * @returns {Promise<boolean>} True if the file exists, false otherwise.
 */
async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Adds metadata to an image file.
 * @async
 * @function
 * @param {string} filePath - The path of the image file.
 * @param {Object} metadata - The metadata to add.
 * @returns {Promise<void>}
 */
async function addMetadata(filePath, metadata) {
  // Implementation depends on the specific metadata format and library used
  // This is a placeholder for the actual implementation
  logger.info(`Adding metadata to ${filePath}:`, metadata);
  // TODO: Implement metadata addition using appropriate library
}

/**
 * Finds the minimum and maximum values in an array of objects for a given property.
 * @function
 * @param {Array<Object>} data - The array of objects to search.
 * @param {string} prop - The property to find min and max values for.
 * @returns {[number, number]} An array containing the minimum and maximum values.
 */
function findMinMax(data, prop) {
  return data.reduce(
    ([min, max], item) => [
      Math.min(min, item[prop]),
      Math.max(max, item[prop])
    ],
    [Infinity, -Infinity]
  );
}

/**
 * Scales a value from one range to another.
 * @function
 * @param {number} value - The value to scale.
 * @param {number} fromMin - The minimum of the original range.
 * @param {number} fromMax - The maximum of the original range.
 * @param {number} toMin - The minimum of the target range.
 * @param {number} toMax - The maximum of the target range.
 * @returns {number} The scaled value.
 */
function scaleValue(value, fromMin, fromMax, toMin, toMax) {
  return ((value - fromMin) / (fromMax - fromMin)) * (toMax - toMin) + toMin;
}

/**
 * Generates a fractal image based on input parameters.
 * @async
 * @function
 * @param {Object} params - Parameters for fractal generation and image creation.
 * @returns {Promise<string>} The path of the saved image file.
 */
export async function generateFractalImage(params) {
  try {
    const fractalData = await processFractalRequest(params);
    if (!fractalData.success) {
      throw new Error(fractalData.message);
    }
    
    const imageOptions = {
      width: params.width || 800,
      height: params.height || 600,
      backgroundColor: params.backgroundColor || '#000000',
      pointColor: params.pointColor || '#FFFFFF',
      pointSize: params.pointSize || 1,
      metadata: {
        model: params.model,
        method: params.method,
        alpha: params.alpha,
        beta: params.beta,
        maxTerms: params.maxTerms
      }
    };

    const parallelComputation = new ParallelComputation();
    const imagePath = await parallelComputation.executeTask(() => createFractalImage(fractalData.data, imageOptions));

    return imagePath;
  } catch (error) {
    logger.error('Error generating fractal image:', error);
    throw error;
  }
}
